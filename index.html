<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Three.js Touch Camera Control</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        // Not using Cannon.js in this specific control example, but keeping the import structure
        // import * as CANNON from 'cannon-es';

        // --- Basic Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeeeeee);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Simple cube to look at
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({ color: 0x0077ff });
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);

        // --- Camera Control Variables ---
        let isDragging = false;
        // Use a single object for previous position (works for mouse and touch)
        const previousPointerPosition = {
            x: 0,
            y: 0
        };

        // --- Mouse Event Listeners ---
        renderer.domElement.addEventListener('mousedown', (event) => {
            isDragging = true;
            previousPointerPosition.x = event.clientX;
            previousPointerPosition.y = event.clientY;
        });

        renderer.domElement.addEventListener('mousemove', (event) => {
            if (!isDragging) return;

            const deltaMove = {
                x: event.clientX - previousPointerPosition.x,
                y: event.clientY - previousPointerPosition.y
            };

            // Simple rotation logic (adjust sensitivity as needed)
            const deltaRotationQuaternion = new THREE.Quaternion()
                .setFromEuler(new THREE.Euler(
                    toRadians(deltaMove.y * 0.5), // Rotate around X axis based on Y movement
                    toRadians(deltaMove.x * 0.5), // Rotate around Y axis based on X movement
                    0,
                    'XYZ' // Order of rotation
                ));

            camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);

            previousPointerPosition.x = event.clientX;
            previousPointerPosition.y = event.clientY;
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('mouseleave', () => { // Stop dragging if mouse leaves canvas
             isDragging = false;
        });

        // --- Touch Event Listeners ---
        renderer.domElement.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) { // Handle single touch for rotation
                // event.preventDefault(); // Prevent default scroll/zoom only if needed
                isDragging = true;
                previousPointerPosition.x = event.touches[0].clientX;
                previousPointerPosition.y = event.touches[0].clientY;
            }
        }, { passive: false }); // Use passive: false if preventDefault is needed

        renderer.domElement.addEventListener('touchmove', (event) => {
            if (!isDragging || event.touches.length !== 1) return;

            // event.preventDefault(); // Prevent default scroll/zoom only if needed

            const deltaMove = {
                x: event.touches[0].clientX - previousPointerPosition.x,
                y: event.touches[0].clientY - previousPointerPosition.y
            };

            // Same rotation logic as mousemove
            const deltaRotationQuaternion = new THREE.Quaternion()
                .setFromEuler(new THREE.Euler(
                    toRadians(deltaMove.y * 0.5),
                    toRadians(deltaMove.x * 0.5),
                    0,
                    'XYZ'
                ));

            camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);

            previousPointerPosition.x = event.touches[0].clientX;
            previousPointerPosition.y = event.touches[0].clientY;
        }, { passive: false }); // Use passive: false if preventDefault is needed


        renderer.domElement.addEventListener('touchend', (event) => {
            // Check if the touch that ended was the one we were tracking
             if (event.touches.length < 1) { // Or check event.changedTouches if needed
                 isDragging = false;
             }
        });


        // --- Utility Function ---
        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            // Any simulation updates would go here
            renderer.render(scene, camera);
        }

        // --- Handle Window Resize ---
         window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate(); // Start the loop

    </script>
</body>
</html>

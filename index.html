<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Three.js + Cannon.js + Touch Controls</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- Scene Setup (Three.js) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeeeeee);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5); // Position camera to see the scene
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows
        document.body.appendChild(renderer.domElement);

        // --- Lighting (Three.js) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // --- Physics Setup (Cannon.js) ---
        const world = new CANNON.World({
            gravity: new CANNON.Vec3(0, -9.82, 0) // Earth's gravity
        });
        world.broadphase = new CANNON.NaiveBroadphase(); // Simple broadphase
        world.solver.iterations = 10; // Physics solver iterations

        // Physics materials
        const groundMaterial = new CANNON.Material('groundMaterial');
        const sphereMaterial = new CANNON.Material('sphereMaterial');
        const groundSphereContactMaterial = new CANNON.ContactMaterial(
            groundMaterial,
            sphereMaterial,
            {
                restitution: 0.5, // Bounciness
                friction: 0.1
            }
        );
        world.addContactMaterial(groundSphereContactMaterial);

        // --- Ground Plane ---
        // Physics Body (Infinite Plane)
        const groundBody = new CANNON.Body({
            type: CANNON.Body.STATIC, // Static object
            shape: new CANNON.Plane(),
            material: groundMaterial
        });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Rotate plane to be horizontal
        world.addBody(groundBody);

        // Visual Mesh (Three.js)
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMeshMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, side: THREE.DoubleSide });
        const groundMesh = new THREE.Mesh(groundGeometry, groundMeshMaterial);
        groundMesh.rotation.x = -Math.PI / 2; // Align visual plane with physics plane
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // --- Sphere ---
        const sphereRadius = 0.5; // meters
        // Physics Body
        const sphereBody = new CANNON.Body({
            mass: 1, // kg
            shape: new CANNON.Sphere(sphereRadius),
            position: new CANNON.Vec3(0, 5, 0), // Initial position (high up)
            material: sphereMaterial
        });
        world.addBody(sphereBody);

        // Visual Mesh (Three.js)
        const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
        const sphereMeshMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff });
        const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMeshMaterial);
        sphereMesh.castShadow = true;
        scene.add(sphereMesh);


        // --- Camera Control Variables ---
        let isDragging = false;
        const previousPointerPosition = { x: 0, y: 0 };

        // --- Mouse Event Listeners ---
        renderer.domElement.addEventListener('mousedown', (event) => {
            isDragging = true;
            previousPointerPosition.x = event.clientX;
            previousPointerPosition.y = event.clientY;
        });

        renderer.domElement.addEventListener('mousemove', (event) => {
            if (!isDragging) return;
            const deltaMove = {
                x: event.clientX - previousPointerPosition.x,
                y: event.clientY - previousPointerPosition.y
            };
            rotateCamera(deltaMove.x, deltaMove.y);
            previousPointerPosition.x = event.clientX;
            previousPointerPosition.y = event.clientY;
        });

        document.addEventListener('mouseup', () => { // Listen on document to catch mouseup outside canvas
            isDragging = false;
        });

        renderer.domElement.addEventListener('mouseleave', () => {
             isDragging = false;
        });

        // --- Touch Event Listeners ---
        renderer.domElement.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                // event.preventDefault(); // Uncomment if needed to prevent scrolling
                isDragging = true;
                previousPointerPosition.x = event.touches[0].clientX;
                previousPointerPosition.y = event.touches[0].clientY;
            }
        }, { passive: true }); // Set passive: true if preventDefault is NOT used

        renderer.domElement.addEventListener('touchmove', (event) => {
            if (!isDragging || event.touches.length !== 1) return;
            // event.preventDefault(); // Uncomment if needed to prevent scrolling
            const deltaMove = {
                x: event.touches[0].clientX - previousPointerPosition.x,
                y: event.touches[0].clientY - previousPointerPosition.y
            };
            rotateCamera(deltaMove.x, deltaMove.y);
            previousPointerPosition.x = event.touches[0].clientX;
            previousPointerPosition.y = event.touches[0].clientY;
        }, { passive: true }); // Set passive: true if preventDefault is NOT used

        renderer.domElement.addEventListener('touchend', (event) => {
             if (event.touches.length < 1) {
                 isDragging = false;
             }
        });

        // --- Camera Rotation Logic ---
        function rotateCamera(deltaX, deltaY) {
            const sensitivity = 0.5; // Adjust sensitivity as needed
            const deltaRotationQuaternion = new THREE.Quaternion()
                .setFromEuler(new THREE.Euler(
                    toRadians(deltaY * sensitivity),
                    toRadians(deltaX * sensitivity),
                    0,
                    'XYZ'
                ));
            camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);
        }

        // --- Utility Function ---
        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        let oldElapsedTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            const deltaTime = elapsedTime - oldElapsedTime;
            oldElapsedTime = elapsedTime;

            // Update physics world
            // Use fixed timestep for stability if needed, or variable like this
            world.step(1 / 60, deltaTime, 3); // Fixed timestep, delta time, max sub-steps

            // Update visual meshes from physics bodies
            sphereMesh.position.copy(sphereBody.position);
            sphereMesh.quaternion.copy(sphereBody.quaternion);
            // Ground plane is static, no update needed

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- Handle Window Resize ---
         window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Start Animation ---
        animate();

    </script>
</body>
</html>
